'''‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚ÄîNo commits?‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
‚†Ä‚£û‚¢Ω‚¢™‚¢£‚¢£‚¢£‚¢´‚°∫‚°µ‚£ù‚°Æ‚£ó‚¢∑‚¢Ω‚¢Ω‚¢Ω‚£Æ‚°∑‚°Ω‚£ú‚£ú‚¢Æ‚¢∫‚£ú‚¢∑‚¢Ω‚¢ù‚°Ω‚£ù
‚†∏‚°∏‚†ú‚†ï‚†ï‚†Å‚¢Å‚¢á‚¢è‚¢Ω‚¢∫‚£™‚°≥‚°ù‚£é‚£è‚¢Ø‚¢û‚°ø‚£ü‚£∑‚£≥‚¢Ø‚°∑‚£Ω‚¢Ω‚¢Ø‚£≥‚£´‚†á
‚†Ä‚†Ä‚¢Ä‚¢Ä‚¢Ñ‚¢¨‚¢™‚°™‚°é‚£Ü‚°à‚†ö‚†ú‚†ï‚†á‚†ó‚†ù‚¢ï‚¢Ø‚¢´‚£û‚£Ø‚£ø‚£ª‚°Ω‚£è‚¢ó‚£ó‚†è‚†Ä
‚†Ä‚†™‚°™‚°™‚£™‚¢™‚¢∫‚¢∏‚¢¢‚¢ì‚¢Ü‚¢§‚¢Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ä‚¢û‚°æ‚£ø‚°Ø‚£è‚¢Æ‚†∑‚†Å‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†à‚†ä‚†Ü‚°É‚†ï‚¢ï‚¢á‚¢á‚¢á‚¢á‚¢á‚¢è‚¢é‚¢é‚¢Ü‚¢Ñ‚†Ä‚¢ë‚£Ω‚£ø‚¢ù‚†≤‚†â‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°ø‚†Ç‚††‚†Ä‚°á‚¢á‚†ï‚¢à‚£Ä‚†Ä‚†Å‚†°‚†£‚°£‚°´‚£Ç‚£ø‚†Ø‚¢™‚†∞‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚°¶‚°ô‚°Ç‚¢Ä‚¢§‚¢£‚†£‚°à‚£æ‚°É‚††‚†Ñ‚†Ä‚°Ñ‚¢±‚£å‚£∂‚¢è‚¢ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚¢ù‚°≤‚£ú‚°Æ‚°è‚¢é‚¢å‚¢Ç‚†ô‚†¢‚†ê‚¢Ä‚¢ò‚¢µ‚£Ω‚£ø‚°ø‚†Å‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†®‚£∫‚°∫‚°ï‚°ï‚°±‚°ë‚°Ü‚°ï‚°Ö‚°ï‚°ú‚°º‚¢Ω‚°ª‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚£≥‚£´‚£æ‚£µ‚£ó‚°µ‚°±‚°°‚¢£‚¢ë‚¢ï‚¢ú‚¢ï‚°ù‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚£¥‚£ø‚£æ‚£ø‚£ø‚£ø‚°ø‚°Ω‚°ë‚¢å‚†™‚°¢‚°£‚££‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚°ü‚°æ‚£ø‚¢ø‚¢ø‚¢µ‚£Ω‚£æ‚£º‚£ò‚¢∏‚¢∏‚£û‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†á‚†°‚†©‚°´‚¢ø‚£ù‚°ª‚°Æ‚£í‚¢Ω‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî'''
from flask import Flask, render_template, request, jsonify
from flask_cors import CORS
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
import threading
import json
import os
import argparse

app = Flask(__name__, static_folder='static')
CORS(app)

# Lock dla bezpiecznego dodawania log√≥w
logs_lock = threading.Lock()
logs = [] 

# Domy≈õlny adres serwera OIOIOI (mo≈ºna nadpisaƒá przez --domain)
DEFAULT_BASE_URL = "https://wyzwania.programuj.edu.pl"
app.config['BASE_URL'] = DEFAULT_BASE_URL

# ≈öcie≈ºka do pliku z kodem Spam (w tym samym katalogu co app.py)
Spam_CODE_PATH = os.path.join(os.path.dirname(__file__), 'spam.cpp') 


def add_log(contest, problem, status, response_text):
    """Dodaje wpis do log√≥w w spos√≥b bezpieczny wƒÖtkowo, uwzglƒôdniajƒÖc contest."""
    with logs_lock:
        logs.append({
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'contest': contest, 
            'problem': problem,
            'status': status,
            'response': response_text[:200]
        })


def submit_solution(token, contest_id, problem, code):
    """Send a single submission to OIOIOI API."""
    url = f"{app.config['BASE_URL']}/api/c/{contest_id}/submit/{problem}"

    headers = {
        'Authorization': f'Token {token}'
    }

    files = {'file': ('solution.cpp', code, 'text/x-c++src')}

    try:
        response = requests.post(url, files=files, headers=headers, timeout=30)
        content_type = response.headers.get('Content-Type', '')

        if 'application/json' in content_type:
            json_response = response.json()
            status = 'OK' if response.status_code == 200 else 'FAIL'
            response_text = json.dumps(json_response, ensure_ascii=False)
        else:
            status = 'FAIL' if response.status_code >= 400 else 'OK'
            response_text = f"HTML [{response.status_code}]: {response.text[:100]}"

        add_log(contest_id, problem, status, response_text)
        return response.status_code == 200

    except requests.exceptions.RequestException as e:
        add_log(contest_id, problem, 'FAIL', f"Exception: {str(e)}")
        return False


# --- Routing ---

@app.route('/')
def index():
    return render_template('index.html')


@app.route('/check_token', methods=['POST'])
def check_token():
    """Sprawdza poprawno≈õƒá tokena przez endpoint /api/auth_ping"""
    data = request.json
    token = data.get('token', '')
    
    if not token:
        return jsonify({'valid': False, 'error': 'Brak tokena'})
    
    try:
        url = f"{BASE_URL}/api/auth_ping"
        headers = {'Authorization': f'Token {token}'} 
        response = requests.get(url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            try:
                user_data = response.json()
                username = user_data.get('username', user_data.get('user', {}).get('username', 'zalogowany'))
                return jsonify({'valid': True, 'username': username})
            except:
                return jsonify({'valid': True, 'username': f'zalogowany {user_data[5:]}'})
        else:
            error_msg = f'Status: {response.status_code}'
            try:
                error_data = response.json()
                error_msg += f' - {error_data}'
            except:
                error_msg += f' - {response.text[:100]}'
            return jsonify({'valid': False, 'error': error_msg})
            
    except Exception as e:
        return jsonify({'valid': False, 'error': str(e)})


@app.route('/single_submit', methods=['POST'])
def single_submit():
    """Wysy≈Ça pojedynczy submit X razy"""
    data = request.json
    token = data.get('token')
    contest_id = data.get('contest')
    problem = data.get('problem')
    code = data.get('code')
    repeat = int(data.get('repeat', 1))
    concurrency = int(data.get('concurrency', 5))
    
    if not all([token, contest_id, problem, code]):
        return jsonify({'success': False, 'error': 'Brak wymaganych danych: token, contest, problem lub kod'}), 400
    
    with ThreadPoolExecutor(max_workers=concurrency) as executor:
        futures = [executor.submit(submit_solution, token, contest_id, problem, code) for _ in range(repeat)]
        results = [f.result() for f in as_completed(futures)] 
    
    success_count = sum(results)
    return jsonify({
        'success': True,
        'message': f'Wys≈Çano {repeat} submit√≥w do {problem} w kont≈õcie {contest_id}. Sukces: {success_count}/{repeat}'
    })


@app.route('/multi_submit', methods=['POST'])
def multi_submit():
    """Wysy≈Ça submity do wielu zada≈Ñ r√≥wnocze≈õnie"""
    data = request.json
    token = data.get('token')
    contest_id = data.get('contest')
    problems_str = data.get('problems', '')
    code = data.get('code')
    repeat = int(data.get('repeat', 1))
    concurrency = int(data.get('concurrency', 10))
    
    if not all([token, contest_id, problems_str, code]):
        return jsonify({'success': False, 'error': 'Brak wymaganych danych: token, contest, problemy lub kod'}), 400
    
    problems = [p.strip() for p in problems_str.split(',') if p.strip()]
    
    if not problems:
        return jsonify({'success': False, 'error': 'Nie podano zada≈Ñ'}), 400
    
    tasks = [(token, contest_id, problem, code) for problem in problems for _ in range(repeat)]
    
    with ThreadPoolExecutor(max_workers=concurrency) as executor:
        futures = [executor.submit(submit_solution, *task) for task in tasks]
        results = [f.result() for f in as_completed(futures)]
    
    success_count = sum(results)
    total = len(tasks)
    
    return jsonify({
        'success': True,
        'message': f'Wys≈Çano {total} submit√≥w do {len(problems)} zada≈Ñ w kont≈õcie {contest_id}. Sukces: {success_count}/{total}'
    })


@app.route('/spam_submit', methods=['POST'])
def Spam_submit():
    """Wysy≈Ça Spam submit, kod ≈Çadowany z pliku Spam.cpp"""
    data = request.get_json(force=True)
    token = data.get('token')
    contest_id = data.get('contest')
    problem = data.get('problem') or data.get('problems')
    repeat = int(data.get('repeat', 1))
    concurrency = int(data.get('concurrency', 5))
    
    if not all([token, contest_id, problem]):
        return jsonify({'success': False, 'error': 'Brak wymaganych danych: token, contest lub problem'}), 400
    
    # Wczytanie kodu z pliku Spam.cpp
    try:
        with open(Spam_CODE_PATH, 'r') as f:
            Spam_code = f.read()
    except FileNotFoundError:
        return jsonify({'success': False, 'error': f'B≈ÇƒÖd: Nie znaleziono pliku {os.path.basename(Spam_CODE_PATH)} w katalogu aplikacji.'}), 500
    except Exception as e:
        return jsonify({'success': False, 'error': f'B≈ÇƒÖd odczytu pliku {os.path.basename(Spam_CODE_PATH)}: {str(e)}'}), 500
    
    with ThreadPoolExecutor(max_workers=concurrency) as executor:
        futures = [executor.submit(submit_solution, token, contest_id, problem, Spam_code) for _ in range(repeat)]
        results = [f.result() for f in as_completed(futures)]
    
    success_count = sum(results)
    return jsonify({
        'success': True,
        'message': f'Wys≈Çano {repeat} spam submit√≥w do {problem} w kont≈õcie {contest_id}. Sukces: {success_count}/{repeat}'
    })


@app.route('/multi_Spam_submit', methods=['POST'])
def multi_Spam_submit():
    """Wysy≈Ça Spam submity do wielu zada≈Ñ r√≥wnocze≈õnie"""
    data = request.json
    token = data.get('token')
    contest_id = data.get('contest')
    problems_str = data.get('problems', '')
    repeat = int(data.get('repeat', 1))
    concurrency = int(data.get('concurrency', 10))
    
    if not all([token, contest_id, problems_str]):
        return jsonify({'success': False, 'error': 'Brak wymaganych danych: token, contest lub problemy'}), 400
    
    problems = [p.strip() for p in problems_str.split(',') if p.strip()]
    
    if not problems:
        return jsonify({'success': False, 'error': 'Nie podano zada≈Ñ'}), 400
    
    # Wczytanie kodu Spam z pliku
    try:
        with open(Spam_CODE_PATH, 'r') as f:
            Spam_code = f.read()
    except FileNotFoundError:
        return jsonify({'success': False, 'error': f'B≈ÇƒÖd: Nie znaleziono pliku {os.path.basename(Spam_CODE_PATH)} w katalogu aplikacji.'}), 500
    except Exception as e:
        return jsonify({'success': False, 'error': f'B≈ÇƒÖd odczytu pliku {os.path.basename(Spam_CODE_PATH)}: {str(e)}'}), 500
    
    tasks = [(token, contest_id, problem, Spam_code) for problem in problems for _ in range(repeat)]
    
    with ThreadPoolExecutor(max_workers=concurrency) as executor:
        futures = [executor.submit(submit_solution, *task) for task in tasks]
        results = [f.result() for f in as_completed(futures)]
    
    success_count = sum(results)
    total = len(tasks)
    
    return jsonify({
        'success': True,
        'message': f'üî• Wys≈Çano {total} spam submit√≥w do {len(problems)} zada≈Ñ w kont≈õcie {contest_id}. Sukces: {success_count}/{total}'
    })


@app.route('/get_logs', methods=['GET'])
def get_logs():
    """Zwraca logi w formacie JSON"""
    with logs_lock:
        return jsonify(logs[-100:][::-1]) 


@app.route('/clear_logs', methods=['POST'])
def clear_logs():
    """Czy≈õci logi"""
    with logs_lock:
        logs.clear()
    return jsonify({'success': True})


# --- New entry point ---
def main():
    """Entry point for running the Rzemie≈õlnik OIOIOI API Server."""
    import argparse
    import sys

    parser = argparse.ArgumentParser(description="Rzemie≈õlnik OIOIOI API Server")
    parser.add_argument('--target', type=str, default="https://wyzwania.programuj.edu.pl")
    parser.add_argument('--port', type=int, default=4000)
    args = parser.parse_args()

    global BASE_URL
    BASE_URL = args.target
    app.config['BASE_URL'] = BASE_URL

    print("üõ†Ô∏è Uruchamianie Rzemie≈õlnik OIOIOI API Server (Flask)...")
    print(f"üåê Cel: {BASE_URL}")
    print(f"üö™ Port: {args.port}")
    print("‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî")

    try:
        app.run(debug=True, host='0.0.0.0', port=args.port, ssl_context='adhoc')
    except KeyboardInterrupt:
        print("\nüõë Zatrzymano serwer rƒôcznie (Ctrl+C).")
        sys.exit(0)


if __name__ == "__main__":
    main()
